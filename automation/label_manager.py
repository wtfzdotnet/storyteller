import logging
import os
import sys

from dotenv import load_dotenv

# Add the parent directory to the path to find ai_core
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))
from github_handler import GitHubService

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Define simplified labels for the streamlined workflow
# Simplified approach: focus on essential organization, not complex state management
ALL_LABELS = {
    # Basic Story Labels
    "story": "1E90FF",  # DodgerBlue - Basic story marker
    "ready-for-development": "32CD32",  # LimeGreen - Ready for dev work
    "in-development": "4169E1",  # RoyalBlue - Currently being worked on
    "completed": "008000",  # Green - Finished
    "blocked": "FF0000",  # Red - Blocked and needs attention
    "on-hold": "A9A9A9",  # DarkGray - Temporarily paused
    
    # Content & Source Labels
    "user_story": "87CEEB",  # SkyBlue - Indicates this is a user story
    "ai_generated": "9370DB",  # MediumPurple - Content generated by AI
    "manual": "32CD32",  # LimeGreen - Manually created content
    
    # Repository-specific labels (for multi-repo mode)
    "backend": "FF6B6B",  # Light Red
    "frontend": "4ECDC4",  # Teal  
    "mobile": "45B7D1",  # Blue
    "api": "96CEB4",  # Sage Green
    "ui": "FFEAA7",  # Light Yellow
    "ux": "DDA0DD",  # Plum
    
    # Priority levels
    "priority/low": "90EE90",  # LightGreen
    "priority/medium": "FFD700",  # Gold
    "priority/high": "FFA500",  # Orange
    "priority/critical": "FF0000",  # Red
    
    # Complexity indicators
    "complexity/simple": "90EE90",  # LightGreen
    "complexity/medium": "FFD700",  # Gold
    "complexity/complex": "FF8C00",  # DarkOrange
    
    # Refactor-specific labels (keep refactor functionality)
    "refactor": "9932CC",  # DarkOrchid
    "refactor/extract": "BA55D3",  # MediumOrchid
    "refactor/move": "8A2BE2",  # BlueViolet
    "refactor/rename": "9400D3",  # Violet
    "refactor/optimize": "FF69B4",  # HotPink
    "refactor/modernize": "FF1493",  # DeepPink
}


class LabelManager:
    def __init__(self):
        # Determine the path to .env. This assumes the script is in ai/ai_core/automation
        # and .env is in the project root, which is three levels up.
        dotenv_path = os.path.join(os.path.dirname(__file__), "..", "..", "..", ".env")

        if os.path.exists(dotenv_path):
            load_dotenv(dotenv_path=dotenv_path)
            logger.info(f"Loaded .env file from: {dotenv_path}")
        else:
            # Fallback for other execution contexts (e.g., when installed as a package or run from root)
            # where .env might be in the current working directory or already loaded.
            load_dotenv()  # Attempts to load .env from cwd or if already in environment
            logger.info(
                f"Attempted to load .env from default location or environment (path checked: {os.getcwd()}/.env)."
            )

        # Initialize GitHubService. It will use GITHUB_TOKEN and GITHUB_REPOSITORY from environment.
        try:
            self.github_service = GitHubService()
        except ValueError as e:
            logger.error(
                f"Failed to initialize GitHubService: {e}. Ensure GITHUB_TOKEN and GITHUB_REPOSITORY are set in your .env file or environment."
            )
            raise  # Re-raise the exception to halt execution if service cannot be initialized.

    def create_or_update_labels(self):
        logger.info("Starting label creation/update process...")
        try:
            existing_labels = self.github_service.get_repository_labels()
        except (
            Exception
        ) as e:  # Catching broader exceptions if get_repository_labels fails critically
            logger.error(
                f"Could not retrieve existing labels from the repository. Aborting. Error: {e}"
            )
            return

        existing_label_map = {label.name: label for label in existing_labels}

        for name, color_hex in ALL_LABELS.items():
            # PyGithub expects color without '#', ensure it's stripped
            clean_color_hex = color_hex.lstrip("#")

            if name in existing_label_map:
                current_label = existing_label_map[name]
                if current_label.color.lower() != clean_color_hex.lower():
                    logger.info(
                        f"Label '{name}' exists but color differs. Current: '{current_label.color}', Target: '{clean_color_hex}'. Updating color."
                    )
                    try:
                        self.github_service.update_label(name, color=clean_color_hex)
                        logger.info(f"Successfully updated color for label '{name}'.")
                    except Exception as e:
                        logger.error(
                            f"Failed to update color for label '{name}'. Error: {e}"
                        )
                else:
                    logger.info(
                        f"Label '{name}' already exists with the correct color '#{clean_color_hex}'. No action needed."
                    )
            else:
                logger.info(
                    f"Label '{name}' does not exist. Creating with color '#{clean_color_hex}'."
                )
                try:
                    # Assuming default description is empty if not specified
                    self.github_service.create_label(
                        name, clean_color_hex, description=""
                    )
                    logger.info(f"Successfully created label '{name}'.")
                except Exception as e:
                    logger.error(f"Failed to create label '{name}'. Error: {e}")

        logger.info("Label creation/update process finished.")


if __name__ == "__main__":
    logger.info("Executing LabelManager script...")
    # This allows the script to be run directly:
    # python -m ai.ai_core.automation.label_manager
    # Make sure PYTHONPATH includes the project root, e.g., export PYTHONPATH=$PYTHONPATH:$(pwd)
    # Or, if your IDE/environment handles it, or if you install your project package.

    # Check for essential environment variables before proceeding
    if not (os.getenv("GITHUB_TOKEN") and os.getenv("GITHUB_REPOSITORY")):
        logger.warning(
            "GITHUB_TOKEN or GITHUB_REPOSITORY environment variables not set."
        )
        # Try to load .env one more time from current directory, just in case script is run from project root
        if os.path.exists(".env"):
            load_dotenv(".env")
            logger.info("Loaded .env from current directory.")

        # Re-check after attempting to load .env from cwd
        if not (os.getenv("GITHUB_TOKEN") and os.getenv("GITHUB_REPOSITORY")):
            logger.error(
                "Critical environment variables GITHUB_TOKEN and GITHUB_REPOSITORY are still missing. "
                "Please ensure they are set in your environment or a .env file accessible by the script. "
                "If running from project root, .env there should be found. "
                "If running as a module, .env in project root should be found by the relative path logic."
            )
            exit(1)  # Exit if still not found

    manager = LabelManager()
    manager.create_or_update_labels()
    logger.info("LabelManager script execution complete.")
