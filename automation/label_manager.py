import logging
import os
import sys
from dotenv import load_dotenv

# Add the parent directory to the path to find ai_core
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
from github_handler import GitHubService 

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Define all labels and their colors (hex codes without '#')
# Sourced from user feedback document
ALL_LABELS = {
    # Core Story Lifecycle States
    "story/draft": "FFA500",  # Orange
    "story/enriching": "1E90FF",  # DodgerBlue
    "story/ready-for-review": "FFD700",  # Gold
    "story/reviewed": "32CD32",  # LimeGreen
    "story/ready-for-dev": "008000",  # Green
    "story/in-development": "4169E1",  # RoyalBlue
    "story/ready-for-qa": "BDB76B",  # DarkKhaki
    "story/in-qa": "DAA520",  # GoldenRod
    "story/qa-approved": "9ACD32",  # YellowGreen
    "story/ready-for-release": "20B2AA",  # LightSeaGreen
    "story/released": "708090",  # SlateGray
    "story/archived": "D3D3D3",  # LightGray
    "story/blocked": "FF0000",  # Red
    "story/on-hold": "A9A9A9",  # DarkGray

    # Enrichment Process States
    "iteration/1": "E6F3FF",  # Light Blue
    "iteration/2": "CCE0FF",  # Medium Blue
    "iteration/3": "B3CDFF",  # Darker Blue
    "iteration/max": "800080",  # Purple (Max iterations reached)
    "consensus/0-20": "FF4444",  # Red
    "consensus/21-40": "FF8C00",  # DarkOrange
    "consensus/41-60": "FFD700",  # Gold
    "consensus/61-80": "9ACD32",  # YellowGreen
    "consensus/81-100": "32CD32",  # LimeGreen

    # Role-Based Needs, Approvals, and Blockers
    "needs/product-owner": "FFC0CB",  # Pink
    "approved/product-owner": "90EE90",  # LightGreen
    "blocking/product-owner": "B22222",  # Firebrick
    "needs/lead-developer": "ADD8E6",  # LightBlue
    "approved/lead-developer": "98FB98",  # PaleGreen
    "blocking/lead-developer": "8B0000",  # DarkRed
    "needs/qa-engineer": "F0E68C",  # Khaki
    "approved/qa-engineer": "90EE90",  # LightGreen (consistent with PO approval)
    "blocking/qa-engineer": "A52A2A",  # Brown
    "needs/ux-designer": "E0FFFF", # LightCyan
    "approved/ux-designer": "AFEEEE", # PaleTurquoise
    "blocking/ux-designer": "5F9EA0", # CadetBlue
    "needs/stakeholder": "D8BFD8", # Thistle
    "approved/stakeholder": "DDA0DD", # Plum
    "blocking/stakeholder": "8A2BE2", # BlueViolet


    # Quality & Complexity Labels
    "quality/invest-compliant": "32CD32",  # LimeGreen
    "quality/needs-invest-refinement": "FFA500",  # Orange
    "complexity/trivial": "90EE90",  # LightGreen
    "complexity/simple": "ADD8E6",  # LightBlue
    "complexity/medium": "FFD700",  # Gold
    "complexity/high": "FF8C00",  # DarkOrange
    "complexity/epic": "FF0000",  # Red

    # Automation Trigger Labels
    "auto/enabled": "00FF00",  # Lime
    "auto/disabled": "FF0000",  # Red
    "trigger/iterate": "1E90FF",  # DodgerBlue
    "trigger/check-consensus": "FFD700",  # Gold
    "trigger/request-feedback": "FF69B4", # HotPink

    # Escalation Types
    "escalation/workshop": "FF69B4",  # HotPink
    "escalation/arbitration": "800080",  # Purple
    "escalation/executive": "DC143C",  # Crimson

    # Finalization Workflow Labels
    "story/finalized": "8A2BE2",  # BlueViolet - Story has been processed and finalized
    "needs/user-approval": "FF1493",  # DeepPink - Awaiting manual user approval
    "approved/user": "00CED1",  # DarkTurquoise - User has approved the finalized story
    
    # Content & Source Labels
    "user_story": "87CEEB",  # SkyBlue - Indicates this is a user story
    "ai_generated": "9370DB",  # MediumPurple - Content generated by AI
    "manual": "32CD32",  # LimeGreen - Manually created content
    
    # Legacy cleanup - these should be migrated to needs/* format
    "needs_feedback": "FFA500",  # Orange - Deprecated, use needs/* specific roles instead
}

class LabelManager:
    def __init__(self):
        # Determine the path to .env. This assumes the script is in ai/ai_core/automation
        # and .env is in the project root, which is three levels up.
        dotenv_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '.env')
        
        if os.path.exists(dotenv_path):
            load_dotenv(dotenv_path=dotenv_path)
            logger.info(f"Loaded .env file from: {dotenv_path}")
        else:
            # Fallback for other execution contexts (e.g., when installed as a package or run from root)
            # where .env might be in the current working directory or already loaded.
            load_dotenv() # Attempts to load .env from cwd or if already in environment
            logger.info(f"Attempted to load .env from default location or environment (path checked: {os.getcwd()}/.env).")

        # Initialize GitHubService. It will use GITHUB_TOKEN and GITHUB_REPOSITORY from environment.
        try:
            self.github_service = GitHubService()
        except ValueError as e:
            logger.error(f"Failed to initialize GitHubService: {e}. Ensure GITHUB_TOKEN and GITHUB_REPOSITORY are set in your .env file or environment.")
            raise  # Re-raise the exception to halt execution if service cannot be initialized.

    def create_or_update_labels(self):
        logger.info("Starting label creation/update process...")
        try:
            existing_labels = self.github_service.get_repository_labels()
        except Exception as e: # Catching broader exceptions if get_repository_labels fails critically
            logger.error(f"Could not retrieve existing labels from the repository. Aborting. Error: {e}")
            return

        existing_label_map = {label.name: label for label in existing_labels}

        for name, color_hex in ALL_LABELS.items():
            # PyGithub expects color without '#', ensure it's stripped
            clean_color_hex = color_hex.lstrip("#")

            if name in existing_label_map:
                current_label = existing_label_map[name]
                if current_label.color.lower() != clean_color_hex.lower():
                    logger.info(f"Label '{name}' exists but color differs. Current: '{current_label.color}', Target: '{clean_color_hex}'. Updating color.")
                    try:
                        self.github_service.update_label(name, color=clean_color_hex)
                        logger.info(f"Successfully updated color for label '{name}'.")
                    except Exception as e:
                        logger.error(f"Failed to update color for label '{name}'. Error: {e}")
                else:
                    logger.info(f"Label '{name}' already exists with the correct color '#{clean_color_hex}'. No action needed.")
            else:
                logger.info(f"Label '{name}' does not exist. Creating with color '#{clean_color_hex}'.")
                try:
                    # Assuming default description is empty if not specified
                    self.github_service.create_label(name, clean_color_hex, description="") 
                    logger.info(f"Successfully created label '{name}'.")
                except Exception as e:
                    logger.error(f"Failed to create label '{name}'. Error: {e}")
        
        logger.info("Label creation/update process finished.")

if __name__ == "__main__":
    logger.info("Executing LabelManager script...")
    # This allows the script to be run directly:
    # python -m ai.ai_core.automation.label_manager
    # Make sure PYTHONPATH includes the project root, e.g., export PYTHONPATH=$PYTHONPATH:$(pwd)
    # Or, if your IDE/environment handles it, or if you install your project package.
    
    # Check for essential environment variables before proceeding
    if not (os.getenv("GITHUB_TOKEN") and os.getenv("GITHUB_REPOSITORY")):
        logger.warning("GITHUB_TOKEN or GITHUB_REPOSITORY environment variables not set.")
        # Try to load .env one more time from current directory, just in case script is run from project root
        if os.path.exists(".env"):
            load_dotenv(".env")
            logger.info("Loaded .env from current directory.")
        
        # Re-check after attempting to load .env from cwd
        if not (os.getenv("GITHUB_TOKEN") and os.getenv("GITHUB_REPOSITORY")):
            logger.error("Critical environment variables GITHUB_TOKEN and GITHUB_REPOSITORY are still missing. "
                         "Please ensure they are set in your environment or a .env file accessible by the script. "
                         "If running from project root, .env there should be found. "
                         "If running as a module, .env in project root should be found by the relative path logic.")
            exit(1) # Exit if still not found

    manager = LabelManager()
    manager.create_or_update_labels()
    logger.info("LabelManager script execution complete.")
